package main

import (
	"encoding/json"
	"fmt"
	"os"
)

// Struct auto-generated from https://mholt.github.io/json-to-go/ by pasting sample json
type AutoGenerated []struct {
	DagCid string `json:"dagCid"`
	Data   struct {
		Cid     string `json:"cid"`
		Type    string `json:"type"`
		Payload struct {
			Contract          string  `json:"contract"`
			TotalTrade        float64 `json:"totalTrade"`
			Token0TradeVolume float64 `json:"token0TradeVolume"`
			Token1TradeVolume float64 `json:"token1TradeVolume"`
			Events            []struct {
				Sender     string `json:"sender"`
				To         string `json:"to"`
				Amount0In  int    `json:"amount0In"`
				Amount1In  int64  `json:"amount1In"`
				Amount0Out int    `json:"amount0Out"`
				Amount1Out int    `json:"amount1Out"`
			} `json:"events"`
			ChainHeightRange struct {
				Begin int `json:"begin"`
				End   int `json:"end"`
			} `json:"chainHeightRange"`
			BroadcastID string  `json:"broadcast_id"`
			Timestamp   float64 `json:"timestamp"`
		} `json:"payload"`
	} `json:"data"`
	Height         int    `json:"height"`
	Timestamp      int    `json:"timestamp"`
	TxHash         string `json:"txHash"`
	PrevDagCid     string `json:"prevDagCid"`
	PayloadChanged bool   `json:"payloadChanged"`
	Diff           struct {
		TotalTrade struct {
			Old float64 `json:"old"`
			New float64 `json:"new"`
		} `json:"totalTrade"`
		Token0TradeVolume struct {
			Old float64 `json:"old"`
			New float64 `json:"new"`
		} `json:"token0TradeVolume"`
		Token1TradeVolume struct {
			Old float64 `json:"old"`
			New float64 `json:"new"`
		} `json:"token1TradeVolume"`
	} `json:"diff"`
}

/* Expects 2 arguments
   1. Json file name to parse.
   2. start and endrange of blocks to verify. If end is -1, verify till latest blockNum in dag.
*/
func main() {
	var dagChain AutoGenerated

	if len(os.Args) < 2 {
		fmt.Println("Please specify dag-chain Json file complete path as an argument.")
		return
	}
	jsonFile := os.Args[1]
	fmt.Println("Verifying DAG Json file:", jsonFile)
	data, err := os.ReadFile(jsonFile)
	if err != nil {
		panic(err)
	}
	//fmt.Println("json data is", string(data))
	parseJson(&data, &dagChain)
	isDagValid := false
	isDagValid = verifyDagForGaps(&dagChain)
	fmt.Println("Dag Chain Valid:", isDagValid)
}

func parseJson(data *[]byte, dagChain *AutoGenerated) {
	//fmt.Println("Parsing Json Data", string(*data))
	err := json.Unmarshal(*data, &dagChain)
	if err != nil {
		fmt.Println("Cannot unmarshal the json ", err)
	}
	//fmt.Println("json data is", string(*data))
}

func verifyDagForGaps(chain *AutoGenerated) bool {
	dagChain := *chain
	fmt.Println("Verifying DAG for gaps. DAG chain length is:", len(dagChain))
	//fmt.Printf("%+v\n", dagChain)
	var prevDagBlockStart, lastBlock, firstBlock, numGaps int
	lastBlock = dagChain[0].Data.Payload.ChainHeightRange.End
	for i := range dagChain {
		//fmt.Println("Processing dag block :", i, "prevBlockStart:", prevDagBlockStart)
		if prevDagBlockStart != 0 {
			curBlockEnd := dagChain[i].Data.Payload.ChainHeightRange.End
			//fmt.Println("curBlockEnd", curBlockEnd, " prevDagBlockStart", prevDagBlockStart)
			if curBlockEnd != prevDagBlockStart-1 {
				fmt.Println("Gap identified at dagBlockCID:", dagChain[i].DagCid, ", between height:", dagChain[i].Height, " and ", dagChain[i-1].Height)
				fmt.Println("Missing blocks from(not including): ", curBlockEnd, " to(not including): ", prevDagBlockStart)
				numGaps++
			}
		}
		prevDagBlockStart = dagChain[i].Data.Payload.ChainHeightRange.Begin
	}
	firstBlock = dagChain[len(dagChain)-1].Data.Payload.ChainHeightRange.Begin
	fmt.Println("Block Range is from:", firstBlock, ", to:", lastBlock)
	fmt.Println("Number of gaps found:", numGaps)
	if numGaps == 0 {
		return true
	} else {
		return false
	}
}
